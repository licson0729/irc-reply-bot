// Generated by CoffeeScript 1.7.1
(function() {
  var CommandManager, EventEmitter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  EventEmitter = require('events').EventEmitter;

  CommandManager = (function(_super) {
    __extends(CommandManager, _super);

    function CommandManager(storage, textRouter) {
      var banCommand, bindCommand, bindListCommand, deopCommand, helpCommand, opCommand, unbanCommand, unbindCommand;
      this.storage = storage;
      this.identifier = "!";
      this.keywordPrefix = "^";
      this.reservedKeyWord = ["help", "op", "deop", "bind", "unbind", "bindlist", "ban", "unban"];
      this.defaultOps = ["mmis1000", "mmis1000_m"];
      this.commands = [];
      this.commandMap = {};
      this.aliasMap = {};
      this.keywords = this.storage.get("keywords", []);
      this.keywordMap = this.storage.get("keywordMap", {});
      helpCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandHelp(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command for print out help message! usage : ", "" + commandPrefix + "    for all commands.", "" + commandPrefix + " [commandName]    for specified command!"];
        },
        hasPermission: function() {
          return true;
        },
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('help', helpCommand, ['?']);
      bindCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandBind(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command bind command to keyword! usage : ", "" + commandPrefix + " keyword commandText.."];
        },
        hasPermission: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager, fromBinding) {
            return !fromBinding;
          };
        })(this),
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('bind', bindCommand, []);
      unbindCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandUnbind(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command unbind command from keyword! usage : ", "" + commandPrefix + " keyword"];
        },
        hasPermission: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager, fromBinding) {
            return !fromBinding;
          };
        })(this),
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('unbind', unbindCommand, []);
      bindListCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandBindList(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command show  keywords! usage : ", "" + commandPrefix];
        },
        hasPermission: (function(_this) {
          return function() {
            return true;
          };
        })(this),
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('bindlist', bindListCommand, []);
      opCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandOp(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command to op someone! usage : ", "" + commandPrefix + " nick"];
        },
        hasPermission: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager, fromBinding) {
            if (fromBinding) {
              return false;
            }
            return commandManager.isOp(sender.sender);
          };
        })(this),
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('op', opCommand, []);
      deopCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandDeop(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command to deop someone! usage : ", "" + commandPrefix + " nick"];
        },
        hasPermission: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager, fromBinding) {
            if (fromBinding) {
              return false;
            }
            return commandManager.isOp(sender.sender);
          };
        })(this),
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('deop', deopCommand, []);
      banCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandBan(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command unbind command from keyword! usage : ", "" + commandPrefix + " nick"];
        },
        hasPermission: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager, fromBinding) {
            if (fromBinding) {
              return false;
            }
            return commandManager.isOp(sender.sender);
          };
        })(this),
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('ban', banCommand, []);
      unbanCommand = {
        handle: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager) {
            return _this._commandUnban(sender, text, args, storage, textRouter, commandManager);
          };
        })(this),
        help: function(commandPrefix) {
          return ["command unbind command from keyword! usage : ", "" + commandPrefix + " nick"];
        },
        hasPermission: (function(_this) {
          return function(sender, text, args, storage, textRouter, commandManager, fromBinding) {
            if (fromBinding) {
              return false;
            }
            return commandManager.isOp(sender.sender);
          };
        })(this),
        handleRaw: function(sender, type, content) {
          return false;
        }
      };
      this.register('unban', unbanCommand, []);
      textRouter.on("input", (function(_this) {
        return function(message, sender) {
          _this.handleRaw(sender, "text", message, textRouter);
          return _this.handleText(sender, message, textRouter);
        };
      })(this));
    }

    CommandManager.prototype.handleRaw = function(sender, type, contents, textRouter) {
      var command, _i, _len, _ref, _results;
      _ref = this.commands;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        command = _ref[_i];
        _results.push(this.commandMap[command].handleRaw(sender, type, contents, textRouter, this));
      }
      return _results;
    };

    CommandManager.prototype.handleText = function(sender, text, textRouter) {
      var args, argsText, command, commandmanager, fromBinding, keyword, result, _i, _len, _ref, _ref1;
      commandmanager = this;
      if (_ref = sender.sender, __indexOf.call(this.storage.get("banList", []), _ref) >= 0) {
        return false;
      }
      result = false;
      if ((text.search(this.identifier)) !== 0) {
        fromBinding = true;
        _ref1 = this.keywords;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          keyword = _ref1[_i];
          try {
            if ((text.search(keyword)) >= 0) {
              text = this.keywordMap[keyword];
              result = true;
              break;
            }
          } catch (_error) {}
        }
      } else {
        fromBinding = false;
        result = true;
      }
      if (!result) {
        return false;
      }
      argsText = text.replace(this.identifier, "");
      argsText = argsText.replace(/^ /g, "");
      args = argsText.split(" ");
      command = args[0];
      if ((this.commands.indexOf(command)) < 0) {
        if (this.aliasMap[command]) {
          command = this.aliasMap[command];
        } else {
          this._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "no such command : " + command + " \ntype '" + this.identifier + " help' for help!");
          return false;
        }
      }
      if (this.commandMap[command].hasPermission(sender, text, args, this.storage, textRouter, commandManager, fromBinding)) {
        if (!this.commandMap[command].handle(sender, text, args, this.storage, textRouter, commandManager)) {
          return this._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, this.commandMap[command].help("" + this.identifier + " " + command));
        }
      } else {
        return this._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, 'access denied!');
      }
    };

    CommandManager.prototype.register = function(keyword, iCommand, aliasList) {
      var command, _i, _len, _results;
      this.commands.push(keyword);
      this.commandMap[keyword] = iCommand;
      _results = [];
      for (_i = 0, _len = aliasList.length; _i < _len; _i++) {
        command = aliasList[_i];
        _results.push(this.aliasMap[command] = keyword);
      }
      return _results;
    };

    CommandManager.prototype.isOp = function(name) {
      var opList;
      opList = this.storage.get("ops", this.defaultOps);
      return __indexOf.call(opList, name) >= 0;
    };

    CommandManager.prototype._sendToPlace = function(textRouter, from, to, channel, message) {
      if (to === channel) {
        return textRouter.output(message, channel);
      } else {
        return textRouter.output(message, from);
      }
    };

    CommandManager.prototype.parseArgs = function(text) {
      var args, argsText;
      argsText = text.replace(this.identifier, "");
      argsText = argsText.replace(/^ /g, "");
      args = argsText.split(" ");
      return args;
    };

    CommandManager.prototype._commandHelp = function(sender, text, args, storage, textRouter, commandManager) {
      if (args.length > 2) {
        return false;
      }
      if (args.length === 1) {
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "all commands : " + (this.commands.join(', ')));
      } else {
        if ((this.commands.indexOf(args[1])) < 0) {
          commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "no such command!");
        } else {
          commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, this.commandMap[args[1]].help("" + this.identifier + " " + args[1]));
        }
      }
      return true;
    };

    CommandManager.prototype._commandBind = function(sender, text, args, storage, textRouter, commandManager) {
      var keyword;
      if (args.length < 3) {
        return false;
      }
      keyword = args[1];
      keyword = keyword.replace(/\\s/g, " ");
      if (!this.isOp(sender.sender)) {
        keyword = this.keywordPrefix + keyword;
        keyword = keyword.replace(/\\/g, "\\\\");
        keyword = keyword.replace(/\./g, "\\.");
        keyword = keyword.replace(/\*/g, "\\*");
        keyword = keyword.replace(/\+/g, "\\+");
        keyword = keyword.replace(/\?/g, "\\?");
        keyword = keyword.replace(/,\}/g, ",5}");
      }
      text = args.slice(2).join(" ");
      if (0 > this.keywords.indexOf(keyword)) {
        if (this.isOp(sender.sender)) {
          this.keywords.unshift(keyword);
        } else {
          this.keywords.push(keyword);
        }
      }
      this.keywordMap[keyword] = text;
      this.storage.set("keywords", this.keywords);
      this.storage.set("keywordMap", this.keywordMap);
      commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "binded " + keyword + " to " + text);
      return true;
    };

    CommandManager.prototype._commandUnbind = function(sender, text, args, storage, textRouter, commandManager) {
      var index, keyword;
      if (args.length !== 2) {
        return false;
      }
      keyword = args[1];
      keyword = keyword.replace(/\\s/g, " ");
      if ((!this.isOp(sender.sender)) && (keyword.search(("\\" + this.keywordPrefix) !== 0))) {
        keyword = this.keywordPrefix + keyword;
      }
      index = this.keywords.indexOf(keyword);
      if (0 <= index) {
        this.keywords.splice(index, 1);
        delete this.keywordMap[keyword];
      }

      /*
      if @isOp sender.sender
        keyword = @keywordPrefix + keyword
        index = @keywords.indexOf keyword
        if 0 <= index
          @keywords.splice index, 1
          delete @keywordMap[keyword]
       */
      this.storage.set("keywords", this.keywords);
      this.storage.set("keywordMap", this.keywordMap);
      commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "unbinded commands from " + keyword);
      return true;
    };

    CommandManager.prototype._commandBindList = function(sender, text, args, storage, textRouter, commandManager) {
      if (args.length !== 1) {
        return false;
      }
      commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "all used keywords : " + (this.keywords.join(', ')));
      return true;
    };

    CommandManager.prototype._commandOp = function(sender, text, args, storage, textRouter, commandManager) {
      var index, ops;
      if (args.length !== 2) {
        return false;
      }
      ops = this.storage.get("ops", this.defaultOps);
      index = ops.indexOf(args[1]);
      if (0 > index) {
        ops.push(args[1]);
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "oped " + args[1]);
      } else {
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "" + args[1] + " is already op!");
      }
      this.storage.set("ops", ops);
      return true;
    };

    CommandManager.prototype._commandDeop = function(sender, text, args, storage, textRouter, commandManager) {
      var index, ops;
      if (args.length !== 2) {
        return false;
      }
      ops = this.storage.get("ops", this.defaultOps);
      index = ops.indexOf(args[1]);
      if (0 > index) {
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "" + args[1] + " is not op");
      } else {
        ops.splice(index, 1);
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "deoped " + args[1]);
      }
      this.storage.set("ops", ops);
      return true;
    };

    CommandManager.prototype._commandBan = function(sender, text, args, storage, textRouter, commandManager) {
      var banList, index;
      if (args.length !== 2) {
        return false;
      }
      banList = this.storage.get("banList", []);
      index = banList.indexOf(args[1]);
      if (0 > index) {
        banList.push(args[1]);
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "banned " + args[1]);
      } else {
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "" + args[1] + " is already banned");
      }
      this.storage.set("banList", banList);
      return true;
    };

    CommandManager.prototype._commandUnban = function(sender, text, args, storage, textRouter, commandManager) {
      var banList, index;
      if (args.length !== 2) {
        return false;
      }
      banList = this.storage.get("banList", []);
      index = banList.indexOf(args[1]);
      if (0 > index) {
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "" + args[1] + " is not banned");
      } else {
        banList.splice(index, 1);
        commandManager._sendToPlace(textRouter, sender.sender, sender.target, sender.channel, "unbanned " + args[1]);
      }
      this.storage.set("banList", banList);
      return true;
    };

    return CommandManager;

  })(EventEmitter);

  module.exports = CommandManager;

}).call(this);
